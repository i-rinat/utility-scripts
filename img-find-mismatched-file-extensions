#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Recursively walks sys.argv[1], for each file checks if file type determined
# by libmagic (also used by "file" utility) corresponds to the file extension.

from natsort import natsorted as naturalsorted
import magic
import multiprocessing
import os
import sys
import tqdm

# Number of files per batch.
NFILES_IN_BATCH = 16

bad_files = {
    'jpeg': [],
    'png':  [],
    'webp': [],
    'gif':  [],
    'mp4':  [],
    'webm': [],
    'ts':   [],
    'gifv': [],
    'known': [],
    'magic': [],
}

magic_checker = magic.Magic()


def check_file_extension(filename):
    fn = filename.lower()
    try:
        m = magic_checker.from_file(filename)
    except magic.MagicException:
        return ('magic', filename)

    if fn.endswith('.jpg') or fn.endswith('.jpeg'):
        if not m.startswith('JPEG image data'):
            return ('jpeg', filename)
        return None

    if fn.endswith('.png') or fn.endswith('.PNG'):
        if not m.startswith('PNG image data'):
            return ('png', filename)
        return None

    if fn.endswith('.webp'):
        if not m.startswith('RIFF (little-endian) data, Web/P image'):
            return ('webp', filename)
        return None

    if fn.endswith('.gif'):
        if not m.startswith('GIF image data'):
            return ('gif', filename)
        return None

    if fn.endswith('.mov') or fn.endswith('.mp4'):
        if not m.startswith('ISO Media, MP4 v2') and \
           not m.startswith('ISO Media, Apple QuickTime movie, Apple QuickTime') and \
           not m.startswith('ISO Media, MP4 Base Media') and \
           not m.startswith('ISO Media, Apple iTunes Video') and \
           not m.startswith('ISO Media, MPEG v4 system') and \
           not m.startswith('ISO Media, MPEG-4 (.MP4) for SonyPSP') and \
           m != 'ISO Media':
            return ('mp4', filename)
        return None

    if fn.endswith('.webm'):
        if not m.startswith('WebM'):
            return ('webm', filename)
        return None

    if fn.endswith('.ts'):
        if not m.startswith('MPEG transport stream data'):
            return ('ts', filename)
        return None

    if fn.endswith('.gifv'):
        if not m.startswith('WebM') and \
           not m.startswith('ISO Media, MP4 Base Media'):
            return ('gifv', filename)
        return None

    return ('known', filename)


def main():
    filename_list = []
    for root, subdirs, files in os.walk(sys.argv[1]):
        if len(files) == 0:
            continue

        for fname in files:
            lc_fname = fname.lower()
            full_fname = os.path.join(root, fname)
            filename_list.append(full_fname)

    pool = multiprocessing.Pool(os.cpu_count())
    progress_bar = tqdm.tqdm(total=len(filename_list))
    num_of_bad_files = 0

    for res in pool.imap_unordered(check_file_extension, filename_list,
                                   NFILES_IN_BATCH):
        progress_bar.update(1)
        if res is not None:
            file_type, file_name = res
            bad_files[file_type].append(file_name)
            num_of_bad_files += 1
            progress_bar.set_postfix(found_bad=num_of_bad_files)

    progress_bar.close()

    all_ok = True
    for file_type in bad_files:
        filelist = naturalsorted(bad_files[file_type])
        if len(filelist) > 0:
            all_ok = False
            print('{:12}{}'.format('not ' + file_type + ':', len(filelist)))
            result_filename = 'not_' + file_type + '.txt'
            with open(result_filename, 'w') as f:
                f.write('\n'.join(filelist) + '\n')

    if all_ok:
        print()
        print('All OK')


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('\ncaught KeyboardInterrupt')
